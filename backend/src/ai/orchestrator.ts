import { sendCampaignEmail } from '../services/emailService.js';
import { logUserInteraction } from '../services/loggingService.js';
import { getUserBehaviorData } from '../services/analyticsService.js';
import { openaiService } from './openaiService.js';
import { supabaseAdmin } from '../services/supabase.js';
import { getAgentConfig } from './agents/config.js';

export type OrchestratorEvent = 'CAMPAIGN_STARTED' | 'CAMPAIGN_VIEWED' | 'ACTION_TAKEN';

export interface OrchestrateEventPayload {
  userId: string;
  campaignId?: string;
  event: OrchestratorEvent;
  agentId?: string;
  metadata?: Record<string, any>;
}

// --- Memoria contextual base (futuro: migrar a Redis o vectores) ---
type MemoryEntry = {
  tenantId: string;
  campaignId: string;
  messages: { role: string; content: string }[];
};
const memoryStore: MemoryEntry[] = [];

/**
 * Orchestrates user events in the system and generates an AI message.
 * Persists the activity in Supabase.
 * @param payload - Event payload
 * @returns message generated by OpenAI
 */
export async function orchestrateEvent({ userId, event, campaignId, agentId }: OrchestrateEventPayload) {
  const config = getAgentConfig(agentId || 'sales');

  const context = {
    userId,
    campaignId,
    event,
    persona: config.persona,
    memory: config.memory || [],
  };

  // Aquí se puede extender para distintos flujos según agentId
  const message = await openaiService.generateAgentMessage({
    systemPrompt: config.prompt,
    context,
  });

  // Guardar en memoria si se activa en el futuro
  if (config.memory) {
    memoryStore.push({
      tenantId: userId,
      campaignId: campaignId || '',
      messages: [
        { role: 'system', content: config.prompt },
        { role: 'user', content: JSON.stringify(context) },
      ],
    });
  }

  return {
    message,
    agentId,
    contextUsed: context,
  };
} 